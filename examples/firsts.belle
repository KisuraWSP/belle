// ========================================================
	// when we need to define the compiler 
	type stack struct{
		stack_region []any,
		size 		 int, // this attribute is needed when we want to restrict the stack otherwise the stack is growable
	}

// ========================================================

// types 
	int (64 bit)
	str 
	uint (64 bit)
	flt (32 bit)
	char (8 bit)
	bool
	region(type, size)

// variables
// each and every action occurs in the stack
// we can explicitly give instructions to the stack
// we dont define the types we just assign a value and the type is defined by the compiler for us
l = ""; // type inferred variable

// constant
l :: "";

// structs
person = type{
	name: str;
	age: u8;	
}

// functions
person_call = func(using p : *person) u8{
	return age;
}

person_call2 = func(using p : *person) (u8, str){
	return age, name;
}

// memory regions or in our case arrays
arr = memory(int, 8);

arr.push(12);
arr.push(121);
arr.pop();
arr.peek();

// basic functions
print(); // displays the output to console
input(); // takes user input


// stack operations
// explicitly telling what operations should the stack do
// the stack supports any operations of any type 
stack.push();
stack.pop();
stack.peek();
stack.restrict(N); // restrict the stack to only N-size operations
stack.pop_all(); // pops all the items in the stack and frees the entire stack

// condition handling 

// if else else_if
if x == 20{
	print(3);
}else_if x == 69{
	print(23);	
	print(23);
	print(23);
}else{
	print(2);
}

// switch case
if x == {
	case 10: print(2);
	
	case 20: print(2);
	
	case 30{
		print(2);
		print(2);
		print(2);
		print(1);
	}
}else{
	print(69420);
}

// single if statement
if (x==69420) print(69420);

// enums
// by default enums are uint type
// we can set enums to any type we want
fruit = enum{
	orange;
	banana = 2;
	apple;
}

vegetable = enum(string){
	p1 = "max verstappen";
	p2 = "carlo sainz";
}
